#!/usr/bin/env bash

# The Penultimate Cloud Image Builder
#
#   This program is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License version 3, as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, see <http://www.gnu.org/licences/>

# Thou must run *everything* successfully or I shall smite thee
set -e
set -o pipefail

# Back to default everything, please
export LANG=C
export LC_ALL=C

ROOT="$(dirname "$(readlink -f "$0")")"
MYNAME="$(basename $0)"

source "$ROOT"/lib/functions.sh

# This is the set of the *unparsed* command line options.  As `optparse` is
# called by plugins, the requested options are removed from this array.  If
# there are any options left after all plugins have been called, then
# unknown options were passed and we'll bomb out.
ARGV=("$@")

# We can't parse configuration file options into OPTS directly, because
# we don't know everything about an option until parseopt is called.
# Instead, we fake up a second ARGV and populate that.
CONFIG_ARGV=()

# A hash containing <optname> => <value> mappings for options which have
# been parsed.
declare -A OPTS

parseopt config true
config="$(optval config)" || :
if [ -n "$config" ]; then
	[ -e "$config" ] || fatal "Configuration file $config does not exist."
	[ -f "$config" ] || fatal "Configuration file $config is not a regular file."
	[ -r "$config" ] || fatal "Configuration file $config is not readable."

	while IFS='=' read opt value; do
		CONFIG_ARGV=("${CONFIG_ARGV[@]}" --"$opt" "$value")
	done < <(grep -Ev '^[[:space:]]*(#.*)?$' "$config")
fi

# Perhaps you'd like to see behind the kimono?
parseopt trace
if [ "$(optval trace)" = y ]; then
	set -x
fi

# Perhaps you'd like some debugging in your day?
parseopt debug
if [ "$(optval debug)" = y ]; then
	DEBUG=y
else
	# You never know when someone might have exported DEBUG into the
	# process environment...
	DEBUG=
fi

parseopt tasklist

# The map of registered task names to task files.
declare -A TASKS

# The list of already-loaded plugins
declare -A PLUGINS

# The list of functions that should be called at exit -- as the trap below
# will do for us automagically.
declare -a CLEANUP_FUNCTIONS

# Basic logging of what's being executed.
log() {
	logger -t "$MYNAME" "$@"
}

# Basic Usage.
pcib_usage() {
	usage_section "Core"

	usage_description
		"There are a few options to PCIB that are always availablei"      \
		"regardless of how it is used."  \

	usage_option "--help" \
		"Display help for all loaded plugins. The help you will see is"   \
		"dependent on which plugins you have selected."

	usage_option "--config <config file>" \
		"Load a configuration file containing additional options."       \
		"Available options are as documented in this help text, in a"    \
		"simple INI-style form (option=value, one per line). Options"    \
		"which do not accept values ignore anything following an ="      \
		"(i.e., option, option= and option=yes are equivalent). Empty"   \
		"lines and lines starting with a hash (#) are ignored."          \
		"Command-line options take precedence over those in"             \
		"configuration files."

	usage_option "--debug" \
		"Print debug logs while executing."

	usage_option "--trace" \
		"Enable execution tracing. ('set -x')"

	usage_option "--tasklist" \
		"Display the list of tasks to be run. If this option is"         \
		"no build will be made; instead, the list of tasks that would"   \
		"be run to complete the build will be printed instead. This is"  \
		"mostly useful for plugin authors, to visualise where their"     \
		"custom tasks should fit, and also for the terminally curious."

	usage_option "--name <imagename>" \
		"What to name the image. (default: 'pcib')"                      \
		"Provide a custom name for the image, which will be used in the" \
		"output filename or in the cloud platform's image store."

	usage_option "--os <os>" \
		"(REQUIRED) Select the OS to install."                           \
		"The supported values for this option are the names of the"      \
		"directories in plugins/os/"

	usage_option "--plugin <plugin>" \
		"Load an additional plugin."                                     \
		"If you wish PCIB to load a completely custom plugin, you may"   \
		"do so with this option. This should be required very rarely,"   \
		"as most plugins will be loaded for you automatically based on"  \
		"the command-line options you specify."
}

register_usage pcib_usage

# There's a few Really Useful misc tasks that live in here
load_plugin_or_die base/pcib

# Load any plugins the user explicitly requested
parseopt plugin true
while optval plugin >/dev/null; do
	load_plugin_or_die "$(optval "plugin")"
	parseopt plugin true
done

# Load the OS platform plugin the user asked for.
parseopt os true
os="$(optval os || true)"
load_plugin_if_exists os/"$os"

# Now that we've loaded all our plugins, we can give the user help if they
# requested it
parseopt help
if [ "$(optval help)" = y ]; then
	usage
	exit 0
fi

# Or, otherwise, complain if they didn't give us everything we wanted
if ! optval os >/dev/null; then
	fatal "Required option --os <os> not provided.  Try $0 --help"
fi

if ! plugindir os/"$os" >/dev/null; then
	fatal "Unknown OS: '$os'"
fi

# Parse out the remaining global options
parseopt name true pcib

# If plugins didn't pluck out all of the provided command-line arguments,
# then the user is probably very confused, and we should help 'em out by
# letting them know.
if [ "${#ARGV}" -gt 0 ]; then
	fatal "Unrecognised command line argument(s): '${ARGV[*]}'.  Try $0 --help"
fi

debug "Configuration options:"
for k in "${!OPTS[@]}"; do
	debug "$k => ${OPTS[$k]}"
done

if [ "${OPTS[tasklist]}" = y ]; then
	for task in $(tasklist); do
		echo "$task ($(plugin_from_path "${TASKS[$task]}"))"
	done
	exit 0
fi

trap "error 'There was an error during the build.  Tidying up before exiting.'; run_cleanups" EXIT

# This is where all the action happens.  If anything bombs out here, we'll
# exit immediately.
run_tasks

# Indicate to cleanup functions that the build did indeed finish
# successfully, and thus they don't need to leave any entrails around for
# later examination.
BUILD_COMPLETE=y

run_cleanups

info "Build complete."

trap "" EXIT
